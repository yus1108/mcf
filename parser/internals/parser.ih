#pragma once

#include "parser.h"

constexpr const char* PARSING_FAIL_MESSAGE_FORMAT = "(Line: %zu)(%zu)\n[Description]: ";

// ASSERT
#if defined(_DEBUG)
#define parsing_fail_assert(PREDICATE, ERROR_ID, TOKEN, FORMAT, ...) if ((PREDICATE) == false) \
{ \
	std::string pfa_message; \
	int pfa_bufferLength = snprintf(nullptr, 0, FORMAT, __VA_ARGS__); \
	char* pfa_buffer = new(std::nothrow) char[pfa_bufferLength + 1]; \
	if (pfa_buffer == nullptr) { return false; } \
	snprintf(pfa_buffer, pfa_bufferLength + 1, FORMAT, __VA_ARGS__); \
	pfa_message += pfa_buffer; delete[] pfa_buffer; \
	pfa_message += "\n"; \
	mcf::parser_error pfa_error = { ERROR_ID, _lexer.get_name(), pfa_message, TOKEN.Line, TOKEN.Index }; \
	_errors.push(pfa_error); \
	__debugbreak(); \
	return false;\
} ((void)0)
#define parsing_fail_message(ERROR_ID, TOKEN, FORMAT, ...) \
{ \
	std::string pfa_message; \
	int pfa_bufferLength = snprintf(nullptr, 0, FORMAT, __VA_ARGS__); \
	char* pfa_buffer = new(std::nothrow) char[pfa_bufferLength + 1]; \
	if (pfa_buffer != nullptr) \
	{ \
	snprintf(pfa_buffer, pfa_bufferLength + 1, FORMAT, __VA_ARGS__); \
	pfa_message += pfa_buffer; delete[] pfa_buffer; \
	pfa_message += "\n"; \
	} \
	mcf::parser_error pfa_error = { ERROR_ID, _lexer.get_name(), pfa_message, TOKEN.Line, TOKEN.Index }; \
	_errors.push( pfa_error ); \
	__debugbreak(); \
} ((void)0)
#else
#define parsing_fail_assert(PREDICATE, ERROR_ID, TOKEN, FORMAT, ...) if ((PREDICATE) == false) \
{ \
	std::string pfa_message; \
	int pfa_bufferLength = snprintf(nullptr, 0, FORMAT, __VA_ARGS__); \
	char* pfa_buffer = new(std::nothrow) char[pfa_bufferLength + 1]; \
	if (pfa_buffer == nullptr) { return false; } \
	snprintf(pfa_buffer, pfa_bufferLength + 1, FORMAT, __VA_ARGS__); \
	pfa_message += pfa_buffer; delete[] pfa_buffer; \
	pfa_message += "\n"; \
	mcf::parser_error pfa_error = { ERROR_ID, _lexer.get_name(), pfa_message, TOKEN.Line, TOKEN.Index }; \
	_errors.push(pfa_error); \
	return false;\
} ((void)0)
#define parsing_fail_message(ERROR_ID, TOKEN, FORMAT, ...) \
{ \
	std::string pfa_message; \
	int pfa_bufferLength = snprintf(nullptr, 0, FORMAT, __VA_ARGS__); \
	char* pfa_buffer = new(std::nothrow) char[pfa_bufferLength + 1]; \
	if (pfa_buffer != nullptr) \
	{ \
	snprintf(pfa_buffer, pfa_bufferLength + 1, FORMAT, __VA_ARGS__); \
	pfa_message += pfa_buffer; delete[] pfa_buffer; \
	pfa_message += "\n"; \
	} \
	mcf::parser_error pfa_error = { ERROR_ID, _lexer.get_name(), pfa_message, TOKEN.Line, TOKEN.Index }; \
	_errors.push( pfa_error ); \
} ((void)0)
#endif

namespace mcf
{
	namespace internal
	{
		constexpr const char* TOKEN_TYPES[] =
		{
			"invalid",
			"eof",

			// 식별자 + 리터럴
			"identifier",
			"integer",
			"string_utf8",

			// 연산자
			"assign",
			"plus",
			"minus",
			"asterisk",
			"slash",
			"bang",
			"equal",
			"not_equal",
			"lt",
			"gt",
			"ampersand",

			"lparen",
			"rparen",
			"lbrace",
			"rbrace",
			"lbracket",
			"rbracket",


			// 구분자
			"colon",
			"double_colon",
			"semicolon",
			"comma",

			// 식별자 키워드
			"keyword_identifier_start",
			"keyword_const",
			"keyword_void",
			"keyword_int8",
			"keyword_int16",
			"keyword_int32",
			"keyword_int64",
			"keyword_uint8",
			"keyword_uint16",
			"keyword_uint32",
			"keyword_uint64",
			"keyword_utf8",
			"keyword_enum",
			"keyword_unused",
			"keyword_in",
			"keyword_out",
			"keyword_bool",
			"keyword_true",
			"keyword_false",
			"keyword_identifier_end",

			"custom_keyword_start",
			"custom_enum_type",
			"custom_keyword_end",

			// '.' 으로 시작하는 토큰
			"keyword_variadic",

			// 매크로
			"macro_start",
			"macro_iibrary_file_include",
			"macro_project_file_include",
			"macro_end",

			"comment",
			"comment_block",
		};
		constexpr const size_t TOKEN_TYPES_SIZE = sizeof(TOKEN_TYPES) / mcf::array_type_size(TOKEN_TYPES);
		static_assert(static_cast<size_t>(mcf::token_type::count) == TOKEN_TYPES_SIZE, "token_type count is changed. this VARIABLE need to be changed as well");
	}
}